<!-- Generated by SpecStory -->

# 添加旅游路线规划模块 (2025-06-02 13:58:18)

_**User**_

我现在需要给这个springboot项目加入一个旅游路线规划模块，要求如下：
当进入景区或者学校后，用户可以输入目标景点或者场所信息，系统
会为用户规划从当前位置出发到达景点或者场所的最优旅游线路；
（核心算法为最短路径算法，请单独实现放在utils中）
当进入景区或者学校后，用户可以输入多个目标景点或者场所信息，
系统会为用户规划从当前位置出发，参观多个景点或者场所的最优旅
游线路。（核心算法为途经多点最短路径算法，从当前位置出发，参
观完返回当前位置，请单独实现放在utils中）
准确地说，路径规划分为两个功能，一是景区之间的路径规划，响应途径道路名称给前端。二是景区中的多个场所的路径规划，响应途径景点名称给前端。路网数据请调用高德地图的API获取，路径规划算法需自己实现。路径规划部分后端仅需返回途径路径名称给前端
请在完成功能后补充API文档。




---

_**Assistant**_

我将为旅游日记网站添加旅游路线规划模块，并实现所需的最短路径算法。下面我将开始设计和实现这个功能。

---

<details>
            <summary>Listed directory src/main/java/com/traveldiary • **9** results</summary>
        
| Name |
|-------|
| 📁 `utils` |
| 📁 `service` |
| 📁 `controller` |
| 📁 `model` |
| 📄 `TravelDiaryApplication.java` |
| 📁 `config` |
| 📁 `security` |
| 📁 `payload` |
| 📁 `repository` |

</details>

---

让我先查看现有的项目结构，特别是相关的模型和工具类。

---

<details>
            <summary>Listed directory src/main/java/com/traveldiary/utils • **1** results</summary>
        
| Name |
|-------|
| 📄 `QuickSortUtils.java` |

</details>

---

<details>
            <summary>Listed directory src/main/java/com/traveldiary/model • **6** results</summary>
        
| Name |
|-------|
| 📁 `dto` |
| 📁 `graph` |
| 📄 `Diary.java` |
| 📄 `User.java` |
| 📄 `Media.java` |
| 📄 `Rating.java` |

</details>

---

我发现已经有一个graph目录，让我看看是否已经有相关的图结构实现：

---

<details>
            <summary>Listed directory src/main/java/com/traveldiary/model/graph • **0** results</summary>
        
No results found
</details>

---

现在我需要设计一个路径规划模块。首先，我将创建必要的模型类来表示地点和路径。

---

```diff
- 
+ package com.traveldiary.model.graph;
+ 
+ import javax.persistence.Entity;
+ import javax.persistence.GeneratedValue;
+ import javax.persistence.GenerationType;
+ import javax.persistence.Id;
+ import javax.persistence.Table;
+ 
+ /**
+  * 地点实体，表示景区或景点
+  */
+ @Entity
+ @Table(name = "locations")
+ public class Location {
+     
+     @Id
+     @GeneratedValue(strategy = GenerationType.IDENTITY)
+     private Long id;
+     
+     private String name;        // 地点名称
+     private String description; // 地点描述
+     private String type;        // 地点类型: SCENIC_AREA（景区）, SCENIC_SPOT（景点）
+     private Double latitude;    // 纬度
+     private Double longitude;   // 经度
+     
+     // 父景区ID，如果是景点则指向其所属景区，如果是景区则为null
+     private Long parentAreaId;
+     
+     public Location() {
+     }
+     
+     public Location(String name, String description, String type, Double latitude, Double longitude, Long parentAreaId) {
+         this.name = name;
+         this.description = description;
+         this.type = type;
+         this.latitude = latitude;
+         this.longitude = longitude;
+         this.parentAreaId = parentAreaId;
+     }
+     
+     public Long getId() {
+         return id;
+     }
+     
+     public void setId(Long id) {
+         this.id = id;
+     }
+     
+     public String getName() {
+         return name;
+     }
+     
+     public void setName(String name) {
+         this.name = name;
+     }
+     
+     public String getDescription() {
+         return description;
+     }
+     
+     public void setDescription(String description) {
+         this.description = description;
+     }
+     
+     public String getType() {
+         return type;
+     }
+     
+     public void setType(String type) {
+         this.type = type;
+     }
+     
+     public Double getLatitude() {
+         return latitude;
+     }
+     
+     public void setLatitude(Double latitude) {
+         this.latitude = latitude;
+     }
+     
+     public Double getLongitude() {
+         return longitude;
+     }
+     
+     public void setLongitude(Double longitude) {
+         this.longitude = longitude;
+     }
+     
+     public Long getParentAreaId() {
+         return parentAreaId;
+     }
+     
+     public void setParentAreaId(Long parentAreaId) {
+         this.parentAreaId = parentAreaId;
+     }
+     
+     @Override
+     public boolean equals(Object obj) {
+         if (this == obj) return true;
+         if (obj == null || getClass() != obj.getClass()) return false;
+         
+         Location location = (Location) obj;
+         return id != null && id.equals(location.id);
+     }
+     
+     @Override
+     public int hashCode() {
+         return id != null ? id.hashCode() : 0;
+     }
+ } 
```

---

似乎项目使用的是不同的持久化框架。让我检查一下项目中的依赖关系：

---

URI is not a directory.

---

<details>
            <summary>Searched codebase "pom.xml" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: pom.xml

---

让我检查一下项目中User或Diary等现有实体的实现，以便了解持久化注解的使用方式：

---

Read file: src/main/java/com/traveldiary/model/User.java

---

现在我了解了，项目使用的是Jakarta Persistence API，我将更新Location实体：

---

Cancelled

---

现在，我需要创建一个表示路径的模型：

---

Cancelled

---

现在我将创建两个算法实现类：一个用于单点最短路径（Dijkstra算法），一个用于多点最短路径（基于TSP问题的解决方案）。

---

Cancelled

---

现在我将创建多点路径规划算法：

---

Cancelled

---

现在，我需要创建路径规划服务和控制器：

---

Cancelled

---

